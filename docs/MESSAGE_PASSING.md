# 智能体消息传递机制

## 概述

在这个"谁是卧底"游戏中，智能体之间**不直接通信**，而是通过共享的 `GameState`（游戏状态）进行**间接通信**。这是一个基于状态的消息传递模式。

## 消息传递架构

```
┌─────────────────────────────────────────────────────────┐
│                    GameState (共享状态)                   │
│  - current_descriptions: 当前轮所有玩家的描述              │
│  - players[].description_history: 每个玩家的历史描述      │
│  - current_votes: 当前轮的投票记录                        │
└─────────────────────────────────────────────────────────┘
         ↑                    ↑                    ↑
         │                    │                    │
    ┌────┴────┐         ┌────┴────┐         ┌────┴────┐
    │ Agent 1 │         │ Agent 2 │         │ Agent 3 │
    └─────────┘         └─────────┘         └─────────┘
```

## 消息传递流程

### 1. 描述阶段 (Description Phase)

**消息流向**：
```
每个 Agent → 生成描述 → 写入 GameState.current_descriptions
                ↓
         GameState.players[].description_history (历史记录)
```

**代码实现** (`nodes.py` - `description_phase()` 函数)

**关键点**：
- Agent 实例持久化保存在 `state["agents_map"]` 中
- Agent 从自己的记忆中读取历史，不需要通过参数传递
- **实时更新**：每个玩家说话后立即更新所有 Agent 的记忆，形成动态推理
- **避免重复**：Agent 在生成描述时，会从记忆中读取当前轮次已说过的描述（排除自己），确保不会重复其他人的描述

**详细实现**：参见 `AGENT_MEMORY.md` 中的"记忆更新流程"部分

### 2. 投票阶段 (Voting Phase)

**消息流向**：
```
GameState.current_descriptions → 每个 Agent → 直接推理投票 → 写入 GameState.current_votes
```

**代码实现** (`nodes.py` - `voting_phase()` 函数)

**关键点**：
- Agent 直接基于完整记忆（所有历史轮次）和当前描述进行推理
- 输出一个详细的分析理由（`reason`）和投票目标（`vote_number`）
- `reason` 包含对所有其他玩家的详细分析过程，包括对自己身份的倾向性判断
- `vote_number` 表示要投票给哪个玩家（玩家ID）
- 每个 Agent 在同一轮投票时看不到其他人的投票（同时投票机制）

**详细实现**：参见 `AGENT_MEMORY.md` 中的"记忆更新流程"部分

## 消息传递的数据结构

### 1. 描述消息 (`current_descriptions`)
```python
[
    {
        "player_id": 1,
        "description": "这是一种常见的水果，通常是红色的",
        "role": "civilian"  # 仅用于调试，智能体看不到
    },
    {
        "player_id": 2,
        "description": "圆形的，可以直接吃",
        "role": "civilian"
    },
    ...
]
```

### 2. 投票消息 (`current_votes`)
```python
[
    {"voter_id": 1, "target_id": 3},
    {"voter_id": 2, "target_id": 3},
    {"voter_id": 3, "target_id": 1},
    ...
]
```

## 关键特性

### ✅ 优点
1. **解耦**：智能体之间不直接依赖，通过 state 间接通信
2. **可观察性**：所有消息都在 state 中，便于调试和记录
3. **状态一致性**：通过 LangGraph 的状态管理保证数据一致性

### ⚠️ 限制
1. **无直接通信**：智能体无法直接发送消息给特定智能体
2. **同步执行**：所有智能体在同一阶段顺序执行，不是并行的
3. **信息可见性**：所有存活智能体都能看到相同的公开信息

## 消息传递时序图

```
Round N:
┌─────────────┬──────────────────────────┬──────────────┐
│ Description │      Voting Phase        │    Check     │
│   Phase     │  (包含分析和投票)         │    Phase     │
├─────────────┼──────────────────────────┼──────────────┤
│ Agent1: 描述1│                          │              │
│ →更新所有记忆│                          │              │
│             │                          │              │
│ Agent2: 描述2│                          │              │
│ →更新所有记忆│                          │              │
│             │                          │              │
│ Agent3: 描述3│                          │              │
│ →更新所有记忆│                          │              │
│             │                          │              │
│ →写入state  │                          │              │
│             │                          │              │
│             │ Agent1: 推理投票        │              │
│             │ Agent2: 推理投票        │              │
│             │ Agent3: 推理投票        │              │
│             │                          │              │
│             │ →写入state               │              │
│             │                          │              │
│             │                          │ 检查胜负条件 │
│             │                          │ 继续/结束    │
└─────────────┴──────────────────────────┴──────────────┘
```

## 代码位置

- **状态定义**: `state.py`
- **消息传递逻辑**: `nodes.py` (各个 phase 函数)
- **智能体处理**: `agents.py` (generate_description, vote)
- **Agent实例持久化**: `state["agents_map"]` 中保存所有Agent实例

## 总结

智能体之间通过共享的 `GameState` 进行间接通信，而不是直接的消息传递。这种设计使得系统更加解耦，便于管理和调试。

